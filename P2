#include <msp430.h> 
#include "clock.h"
#include "pmm.h"
#include <stdint.h>
#include <intrinsics.h>

#define TA0_CCRN_VECTOR 52         // Timer A0 CCR1,2,3,4 interruption priority
void Init();
void trig();
void calc_dist();
void leds();
uint32_t CONTADOR = 0;
uint32_t DIST = 0;
void main()
{
    // Stop watchdog timer
    WDTCTL = WDTPW | WDTHOLD;

    // Increase core voltage so CPU can run at 16Mhz
    // Step 1 allows clocks up to 12MHz, step 2 allows rising MCLK to 16MHz
    pmmVCore(1);
    pmmVCore(2);

    // Configure clock
    // This should make MCLK @16MHz, SMCLK @1MHz and ACLK @32768Hz
    clockInit();

    // Your program here...
    Init();
    TA0CCTL1 |= CM_3 | CCIS_0 | SCS | CAP | CCIE;

    TA0CTL |= TASSEL__SMCLK |   // 1048576 Hz
                  MC_2          |   // modo continuous (0xFFFF)
                  TACLR;            // limpa o Timer A


    // Inicializar Pinos e setar SMCLK
    __enable_interrupt();
    _BIS_SR(GIE);

    // Enable Global Interrupt e Local Interrupt

    while (1){ };
    // loop infinito aqui ?? nao ta indo no interrupt;



}


void Init (){
    // Buzzer
    P2DIR |= BIT5;
    P2OUT &= ~BIT5;

                    // LEDs
    P1DIR |= BIT0;              // direção de saída
    P1OUT &= ~BIT0;             // LED vermelho off

    P4DIR |= BIT7;              // direção de saída
    P4OUT &= ~BIT7;             // LED verde off

                    // TRIGGER (P1.5)
    P1DIR |= BIT5;              // direção de saída (uC manda informação)
    P1OUT &= ~BIT5;             // início em 0 V

                    // Echo (P2.0)
    P2DIR &= ~BIT0;             // direção de entrada (sensor manda informação)
    P2SEL |= BIT0;              // modo de captura utlizado (TA0.1)



}


                    // CALCULA DISTANCIA EM CM
void calc_dist(){
    DIST = CONTADOR/1048576;
    DIST *= 12000;

}

                    // CCR1 = TRIGGER// CCR2 = ECHO LEITURAS// CCR3 = BUZZER ATIVA
#pragma vector=TA0_CCRN_VECTOR
__interrupt void TA0_CCRN_ISR(){
    switch(TA0IV){
      case 2:
                  P1OUT |= BIT0;            // LIGAR LED SO PRA VER SE ENTRA NESSE CASO
                  __delay_cycles(50000);   // debounce
                  P1OUT ^= BIT5;          // ON
                  __delay_cycles(10);     // Trigger Pulse
                  P1OUT ^= BIT5;          // OFF

        break;
      case 4:
                  P1OUT |= BIT0;            // LIGAR LED SO PRA VER SE ENTRA NESSE CASO
                  if(TA0CCTL1 & CCI)
                  {
                          CONTADOR = TA0CCR1; //takes first time measure in us
                  }
                  else if(!(TA0CCTL1 & CCI))
                  {
                          CONTADOR = TA0CCR1 - CONTADOR;
                          calc_dist();
                          leds();

                  }
        break;
      case 6:break;
          // Buzzer;
    default: break;
    }
}



void leds()
{
    if (DIST <= 50)
    {
                // Turn on LED
        if(DIST < 10)
        {             // até 20cm
                   P1OUT |= BIT0;          // LED vermelho on
                   P4OUT |= BIT7;         // LED verde off
        }
        else if(DIST < 30)
                {      // entre 20 e 40cm
                   P1OUT |= BIT0;          // LED verde on
                   P4OUT &= ~BIT7;         // LED vermelho off
                }
        else{                       // além de 40cm
                   P4OUT |= BIT7;          // LED verde on
                   P1OUT &= ~BIT0;
            }
    }
    else
    {         // Turn off LED
        P1OUT &= ~BIT0;
        P4OUT &= ~BIT7;
    }

}



