#include <msp430.h> 
#include "clock.h"
#include "pmm.h"
#include <stdint.h>
#include <intrinsics.h>

#define TA0_CCRN_INT 52         // Timer A0 CCR1,2,3,4 interruption priority
void Init();
void trig();
void calc_dist();
void leds();
uint32_t CONTADOR = 0;
uint32_t DIST = 0;
void main()
{
    // Stop watchdog timer
    WDTCTL = WDTPW | WDTHOLD;

    // Increase core voltage so CPU can run at 16Mhz
    // Step 1 allows clocks up to 12MHz, step 2 allows rising MCLK to 16MHz
    pmmVCore(1);
    pmmVCore(2);

    // Configure clock
    // This should make MCLK @16MHz, SMCLK @1MHz and ACLK @32768Hz
    clockInit();

    // Your program here...
    Init();
    TA0CCTL1 |= CM_3 | CCIS_0 | SCS | CAP | CCIE;
    TA0CCTL0 |= CM_3 | CCIS_0 | SCS | CAP | CCIE;


    TA0CTL |= TASSEL__SMCLK |   // 1048576 Hz
                  MC_2          |   // modo continuous (0xFFFF)
                  TACLR;            // limpa o Timer A
    // Inicializar Pinos e setar SMCLK
    _BIS_SR(GIE);

    while (1){ };



}


void Init (){
    // Buzzer
    P2DIR |= BIT5;
    P2OUT &= ~BIT5;

                    // LEDs
    P1DIR |= BIT0;              // direção de saída
    P1OUT &= ~BIT0;             // LED vermelho off

    P4DIR |= BIT7;              // direção de saída
    P4OUT &= ~BIT7;             // LED verde off

                    // TRIGGER (P1.3)
    P1DIR |= BIT5;              // direção de saída (uC manda informação)
    P1OUT &= ~BIT5;             // início em 0 V

    // Echo (P1.2)https://github.com/Tubar2/SisMic/blob/master/Lab/Prob_2/main.c
    P2DIR &= ~BIT0;             // direção de entrada (sensor manda informação)
    P2SEL |= BIT0;              // modo de captura utlizado (TA0.1)



}



void calc_dist(){
    DIST = CONTADOR/1048576;
    DIST *= 12000;

}

#pragma vector=TA0_CCRN_INT
__interrupt void TA0_CCRN_ISR(){
    switch(TA0IV){
      case 2:
          P1OUT |= BIT0;
                  __delay_cycles(50000);   // debounce
                  P1OUT ^= BIT5;          // ON
                  __delay_cycles(10);     // Trigger Pulse
                  P1OUT ^= BIT5;          // OFF
        
        break;
      case 4:
          P1OUT |= BIT0;// CCR1
                  if(TA0CCTL1 & CCI){ // Read the CCI bit (ECHO signal) --> CCI reflects the state of Captura pin --> ECHO signal
                          CONTADOR = TA0CCR1; //takes first time measure in us
                      }
                  else if(!(TA0CCTL1 & CCI)){
                          CONTADOR = TA0CCR1 - CONTADOR;
                          calc_dist();
                          leds();

                          // to obtain distance in centimeters: (time in us/58) --> (see Datasheet HC-SR04)
                      }
                  break;
      case 6:    
          // Buzzer;
    default: break;
    }
}



void leds()
{
    if (DIST <= 50)
    {
                // Turn on LED
        if(DIST < 10)
        {             // até 20cm
                   P1OUT |= BIT0;          // LED vermelho on
                   P4OUT |= BIT7;         // LED verde off
        }
        else if(DIST < 30)
                {      // entre 20 e 40cm
                   P1OUT |= BIT0;          // LED verde on
                   P4OUT &= ~BIT7;         // LED vermelho off
                }
        else{                       // além de 40cm
                   P4OUT |= BIT7;          // LED verde on
                   P1OUT &= ~BIT0;
            }
    }
    else
    {         // Turn off LED
        P1OUT &= ~BIT0;
        P4OUT &= ~BIT7;
    }

}



